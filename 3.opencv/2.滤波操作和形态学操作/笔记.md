## 前置知识-卷积

​	图像的本质是三维矩阵，为了简单，我们**用灰度图-单通道图像举例**。

​	**卷积核**是一个矩阵，常用奇数边长，如**3,5,7等作为卷积核的大小**，如**3 * 3** 的，5 * 5的卷积核很常见。卷积核是什么? 简单说，卷积核是应用于卷积操作的一个**工具权重矩阵**，又叫做**滤波器**（Filter）。其每一个位置的值本质上是一个权重，这需要我们先理解卷积操作。

​	**卷积**操作指的是对一个图像（二维矩阵）进行遍历，**遍历每一个像素**，每一次遍历处理中，**以选中像素位置为中心，选中卷积核大小的区域**，如3 * 3的区域-这个区域叫做**感受野**。让**感受野和卷积核作点乘** - 对应位置相乘最后求和，**得到一个数**（这里我们**假设卷积核元素求和是1，即权重和为1**）。这样得到的这个数不会超过范围（因为感受野的每一个数都确保合法），**不需要后处理**。

​	假设**卷积核没有归一化**（卷积核的归一化指的是让卷积核的元素和为1，只需要让原数/卷积核元素和即可实现归一化），**可能需要对计算结果进行后处理，如归一化**（这里的归一化可以是映射到0-255范围内，最大的数映射为255，以此类推。）然后让计算结果代替原位置的数。每个像素都如此进行，得到卷积后的图像。

​	特殊地，对于边缘的像素，周围不存在一个元素和卷积核的对应位置运算，就可以采用padding，即填充一些常量像素的方式临时补全。

## 滤波

​	滤波操作本质上是一种模糊的卷积操作，通过让一个像素周围的一些像素进行一定的加权替换掉自己，实现消除一些噪音点的效果。均值滤波的思想要了解，高斯滤波和中值滤波要掌握，中值滤波的效果最好。

1.均值滤波

​	均值滤波指的是，对感受野内的所有值求平均数代替中间位置像素值。此时感受野内所有像素的权值是一样的，比如kernel的大小是 3 * 3，那么每一个像素的权重就是1/9，显然效果是不太好的。

​	blur即均值滤波，传入待滤波的图，以及卷积核的规模元组。

=> 补充**numpy中可以进行矩阵的水平或垂直展示**，即矩阵的水平或垂直拼接

```python
img_avg_blur = cv2.blur(img, (3,3))  # 均值滤波
res1 = np.hstack((img,img_avg_blur)) # 传入合并元组，传入到hstack函数中，即可获得新的矩阵。方便对比。
show_img(res1)
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903123858465.png" width="400px">

​	此外，还有一个实现均值滤波的手段 - 方框滤波，即boxFilter函数，需要传入四个参数，第二个参数恒为-1，最后一个参数显式指定normalize =  True，意思是归一化。

```python
img_avg_blur = cv2.boxFilter(img, -1, (3,3), normalize=True)
res1 = np.hstack((img,img_avg_blur))
show_img(res1)
```

2.高斯滤波

​	均值滤波的缺陷在于每个感受野元素都是同等地位，显然是不合理的，而如果越靠近中心像素的权重越大就好了，我们想起了正态分布，正态分布的函数又叫做高斯函数，所以卷积核如果采用高斯函数生成 - （x，y）代表矩阵元素的位置，G(x,y)生成卷积核的元素。这样可以确保中心位置的权重最大-kernel的值越大。

如下图所示是高斯函数：二维的对应的图为钟形。

![image-20250903122256114](%E7%AC%94%E8%AE%B0.assets/image-20250903122256114.png)

```python
img_gaus_blur = cv2.GaussianBlur(img, (3, 3), 1)  # 第三个参数1表示高斯函数的标准差xigema
res1 = np.hstack((img,img_gaus_blur))
show_img(res1)
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903124012933.png" width="400px">

3.中值滤波

​	中值滤波是把感受野的元素取中位数作为中间元素卷积。中值滤波是所有滤波中效果最好的，lyf的图效果还不是那么好因为噪声太密集，我们换一个图。

```python
cat = cv2.imread('cat-noise.png')
cat_med_blur = cv2.medianBlur(cat, 5) # 第二个参数是以该像素为中心的感受野边长-也可以理解为卷积核的规模
res3 = np.hstack((cat, cat_med_blur))
show_img(res3)
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903123438446.png" width="400px">

​	这是感受野边长为7时的效果。发现效果更好了。

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903123622872.png" width="400px">

## 二值化-阈值操作

​	阈值操作指的是传入一个阈值，遍历图像的每一个像素，如果超过阈值，就执行什么操作，我们要学的就是这些策略。 阈值策略的函数是`_, dst = cv2.threshold(img, thresh, max_val, strategy)` 

​	其中我们需要传入图片矩阵img，传入阈值thresh， 传入最大上限值，一般为255， 我们要学习的是第四个参数。返回值第一个不重要，是实际使用的阈值，大部分情况下等于第二个参数thresh，第二个是处理之后的图片矩阵dst。

1.策略1-二值化：`cv2.THRESH_BINARY`, 二值化，即超过阈值的就放大为max_val，低于阈值的缩小为0，即白的非常白，黑的变为最黑。 // 注意先把图片cvt到灰度图再传入二值化操作。注意第一个返回值不用。

```python
# 二值化 - 阈值操作
_, cat1 = cv2.threshold(cv2.cvtColor(cat, cv2.COLOR_BGR2GRAY), 127, 255, cv2.THRESH_BINARY)
show_img(cat1)
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903143748946.png" width="200px">

​	与之相对的是：`cv2.THERESH_BINARY_INV`，即invert翻转，和上一个相反，低于阈值的都变为最大值max_val，高于阈值的都变为0，即黑色。

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903143809084.png" width="200px">

2.策略2: `cv2.THRESH_TRUNC` 这个策略指的是截断，大于阈值的部分都设置位阈值，其它不变。记忆为如下图所示

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903144414208.png" width="200px">

```python
# 截断阈值 - 阈值操作
_, cat1 = cv2.threshold(cv2.cvtColor(cat, cv2.COLOR_BGR2GRAY), 127, 255, cv2.THRESH_TRUNC)
show_img(cat1)
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903144459680.png" width="200px">

3.策略3：`cv2.THRESH_TOZERO` 这个策略指的是小于阈值的都归0，其它不变。

```python
# tozero阈值 - 阈值操作
_, cat1 = cv2.threshold(cv2.cvtColor(cat, cv2.COLOR_BGR2GRAY), 127, 255, cv2.THRESH_TOZERO)
show_img(cat1)
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903144639667.png" width="200px">

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903144752487.png" width="200px">

​	与之相对的是`cv2.THRESH_TOZERO_INV` 即和上面tozero相反。小于阈值的不变，大于阈值的归0.

```python
# tozero—inv阈值 - 阈值操作
_, cat1 = cv2.threshold(cv2.cvtColor(cat, cv2.COLOR_BGR2GRAY), 127, 255, cv2.THRESH_TOZERO_INV)
show_img(cat1)
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903144830203.png" width="200px">

## 形态学操作-腐蚀和膨胀

=> 补充numpy中的生成全1的矩阵函数`np.ones(shape, dtype)`

​	比如我想生成一个3 * 3的dtype为uint8的全1矩阵作为卷积核，可以这么写：

```python
kernel = np.ones((3, 3), np.uint8)
```

=> 补充前景和背景的知识

​	前景一般指的是白色，即255，背景一般指黑色，即0.对于一般的灰度图，可以通过二值化之后，就可以很轻松得到白色和黑色的图。白色为前景，黑色为背景。

1.腐蚀操作 - **erode方法**

​	①作用和用法：效果上，腐蚀操作指的是让前景区域的边界收缩，即前景区域变的更小，被背景腐蚀掉。用法上，erode方法的用法是：`img_1 = cv2.erode(img, kernel, iterations=1)` 第三个参数是显式的迭代次数，迭代次数越多，腐蚀的效果越强。kernel是一个卷积核，一般用全1的矩阵，可以用np.ones生成。

​	②原理：遍历每一个像素点，如果是前景色（我就说白色了）为中心点，如果感受野内都是白色，那该点保留为白色，如果感受野内出现了一个黑色，那该点被替换为黑色，即被腐蚀为黑色。

代码：

```python
gray_cat = cv2.cvtColor(cat, cv2.COLOR_BGR2GRAY)
show_img(gray_cat)
# 二值化
_, b_gray_cat = cv2.threshold(gray_cat, 127, 255, cv2.THRESH_BINARY)
# 腐蚀
erode_cat = cv2.erode(b_gray_cat, np.ones((5,5), np.uint8), iterations=1)
res = np.hstack((b_gray_cat, erode_cat))
show_img(res)
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903150940267.png" width="400px">

​	可以发现白色的小点点被侵蚀了。而且之前前景色-白色区域的边界也内缩了。而且我们的卷积核的规模越大，腐蚀效果越强，相当于缩小的边界范围越大；迭代次数越大，效果越强。上图是迭代1次，卷积核是5的效果。 我们试试迭代两次的效果。

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903151237002.png" width="400px">

2.膨胀操作 - **dilate方法**

​	①用法：`img = cv2.dilate(img_binary, kernal, iterations)`	

​	②原理：膨胀操作和腐蚀是相反的，如果卷积核内全是背景色，则保留背景色，如果只要有一个是前景色，则用前景色替换为当前的像素值，给人的感觉是白色的部分变粗了。参数和erode是一样的。

​	迭代次数越大，膨胀效果越明显；卷积核规模越大，效果越明显。

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903151721728.png" width="400px">

3.形态学梯度计算

​	分析：所谓形态学的梯度计算，你可以理解为是像素变化的时候，如果突然发生由黑色到白色，这说明梯度很大，形态学的梯度计算就是要找到这些“边缘”。 计算公式是`膨胀 - 腐蚀`。

​	方法： `img = cv2.morphologyEx(img, cv2.MORPH_GRADIANT, kernel)`,这里的kernel也是全1矩阵。

```python
# 形态学梯度计算
grad_cat = cv2.morphologyEx(b_gray_cat, cv2.MORPH_GRADIENT, np.ones((3, 3), np.uint8))
show_img(np.hstack((b_gray_cat, grad_cat)))
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903153431038.png" width="400px">

4.形态学开运算和闭运算

​	同样还是一样的函数，形态学开运算只是传入的参数变为了`cv2.MORPH_OPEN` 意思是先进行腐蚀，再膨胀。

```python
# 形态学开运算计算
open_cat = cv2.morphologyEx(b_gray_cat, cv2.MORPH_OPEN, np.ones((3, 3), np.uint8))
show_img(np.hstack((b_gray_cat, open_cat)))
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903153722244.png" width="400px">

​	形态学闭运算传入参数的策略变为了`cv2.MORPH_CLOSE` 意思是先膨胀，再腐蚀。

```python
# 形态学闭运算
close_cat = cv2.morphologyEx(b_gray_cat, cv2.MORPH_CLOSE, np.ones((3, 3), np.uint8))
show_img(np.hstack((b_gray_cat, close_cat)))
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903153719859.png" width="400px">

5.形态学顶帽和黑帽

​	这个有点抽象，顶帽也是形态学方法的一种策略，即`cv2.MORPH_TOPHAT`,意思是原始图 - 开运算； 而黑帽则相反，传入的参数是`cv2.MORPH_BLACK`，原理是闭运算 - 原始图。

①顶帽

```python
# 形态学顶帽
top_cat = cv2.morphologyEx(b_gray_cat, cv2.MORPH_TOPHAT, np.ones((3, 3), np.uint8))
show_img(np.hstack((b_gray_cat, top_cat)))
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903154128088.png" width="400px">

②黑帽

```python
# 形态学黑帽
black_hat = cv2.morphologyEx(b_gray_cat, cv2.MORPH_BLACKHAT, np.ones((3, 3), np.uint8))
show_img(np.hstack((b_gray_cat, black_hat)))
```

<img src="%E7%AC%94%E8%AE%B0.assets/image-20250903154231023.png" width="400px">

// 2025年9月3日15:44:04 finished